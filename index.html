<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Turbo Rush — Car Racing Game</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;800&family=Outfit:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0c0e14;
      --bg-card: #151922;
      --accent: #00d4aa;
      --accent-glow: rgba(0, 212, 170, 0.4);
      --danger: #ff4757;
      --text: #e8eaed;
      --text-muted: #8b9199;
      --road: #1e2229;
      --line: #2d3544;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Outfit', sans-serif;
      background: var(--bg-dark);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
      color: var(--text);
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse 80% 50% at 50% 0%, rgba(0, 212, 170, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse 60% 40% at 80% 100%, rgba(255, 71, 87, 0.05) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .game-wrapper {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 24px;
    }

    .logo {
      font-family: 'Orbitron', sans-serif;
      font-weight: 800;
      font-size: clamp(1.75rem, 5vw, 2.25rem);
      letter-spacing: 0.15em;
      background: linear-gradient(135deg, var(--accent) 0%, #00a88a 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-transform: uppercase;
    }

    .game-container {
      position: relative;
      background: var(--bg-card);
      border-radius: 20px;
      padding: 16px;
      box-shadow: 
        0 25px 50px -12px rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(255, 255, 255, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }

    .score-bar {
      position: relative;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      margin-bottom: 12px;
      background: rgba(0, 0, 0, 0.35);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .score-bar span {
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    .score-bar strong {
      color: var(--accent);
      font-size: 1.1rem;
      margin-left: 6px;
    }

    .boost-indicator {
      position: absolute;
      top: 12px;
      right: 20px;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      color: var(--accent);
      opacity: 0;
      transition: opacity 0.2s;
    }
    .boost-indicator.active {
      opacity: 1;
      animation: boost-pulse 0.5s ease infinite alternate;
    }
    @keyframes boost-pulse {
      from { opacity: 0.8; }
      to { opacity: 1; }
    }

    #gameCanvas {
      display: block;
      background: var(--road);
      border-radius: 12px;
      outline: none;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .controls {
      display: flex;
      gap: 24px;
      margin-top: 8px;
      justify-content: center;
    }

    .control-btn {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(145deg, var(--line) 0%, #252a35 100%);
      color: var(--accent);
      font-size: 1.5rem;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover {
      background: linear-gradient(145deg, #2d3544 0%, #353d4a 100%);
      transform: scale(1.03);
    }

    .control-btn:active {
      transform: scale(0.96);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .control-btn svg {
      width: 28px;
      height: 28px;
    }

    .hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      text-align: center;
    }

    .mobile-hint { display: none; }

    @media (max-width: 767px) {
      .desktop-hint { display: none; }
      .mobile-hint { display: block; }
    }

    .overlay {
      position: absolute;
      inset: 16px;
      background: rgba(12, 14, 20, 0.95);
      backdrop-filter: blur(12px);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .overlay h2 {
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: clamp(1.5rem, 4vw, 2rem);
      color: var(--text);
    }

    .overlay p {
      font-size: 1rem;
      color: var(--text-muted);
    }

    .start-btn {
      padding: 16px 48px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 600;
      font-size: 1rem;
      letter-spacing: 0.1em;
      background: linear-gradient(135deg, var(--accent) 0%, #00a88a 100%);
      border: none;
      border-radius: 12px;
      color: #0c0e14;
      cursor: pointer;
      box-shadow: 0 4px 20px var(--accent-glow);
      transition: all 0.2s ease;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 28px var(--accent-glow);
    }

    .start-btn:active {
      transform: translateY(0);
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <h1 class="logo">Turbo Rush</h1>
    <div class="game-container">
      <div class="score-bar">
        <span>Score <strong id="score">0</strong></span>
        <span>Best <strong id="best">0</strong></span>
        <span class="boost-indicator" id="boostIndicator">TURBO</span>
      </div>
      <div id="startOverlay" class="overlay">
        <h2>Ready to Race</h2>
        <p>One lane is always clear — find it!</p>
        <button class="start-btn" id="startBtn">Start</button>
      </div>
      <div id="gameOverOverlay" class="overlay hidden">
        <h2>Game Over</h2>
        <p>Score: <strong id="finalScore">0</strong></p>
        <button class="start-btn" id="restartBtn">Play Again</button>
      </div>
      <canvas id="gameCanvas" width="400" height="600" tabindex="0"></canvas>
    </div>
    <div class="controls">
      <button type="button" class="control-btn" id="leftBtn" aria-label="Left">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M15 18l-6-6 6-6"/></svg>
      </button>
      <button type="button" class="control-btn" id="rightBtn" aria-label="Right">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M9 18l6-6-6-6"/></svg>
      </button>
    </div>
    <p class="hint desktop-hint">Arrow keys to steer · Tap anywhere for speed boost</p>
    <p class="hint mobile-hint">Swipe to steer · Tap anywhere for speed boost</p>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function resizeCanvas() {
      const maxWidth = Math.min(400, window.innerWidth - 48);
      canvas.width = maxWidth;
      canvas.height = (maxWidth / 400) * 600;
      if (gameRunning) draw();
    }

    let gameRunning = false;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('carGameBest') || '0');
    let animationId;

    const player = { x: 0, y: 0, width: 0, height: 0, lane: 1 };
    const LANES = 3;
    let obstacles = [];
    let roadOffset = 0;
    let boostActive = false;
    let boostEndTime = 0;
    const BOOST_DURATION = 2500;
    const BOOST_MULTIPLIER = 1.6;
    let isCrashing = false;
    let crashFrame = 0;
    const CRASH_DURATION = 45;
    let lastTouchTime = 0;
    const TOUCH_DEBOUNCE = 150;

    function initGame() {
      const laneWidth = canvas.width / LANES;
      player.width = laneWidth * 0.65;
      player.height = player.width * 1.4;
      player.lane = 1;
      player.x = laneWidth * player.lane + (laneWidth - player.width) / 2;
      player.y = canvas.height - player.height - 25;
      obstacles = [];
      score = 0;
      roadOffset = 0;
      boostActive = false;
      isCrashing = false;
      document.getElementById('score').textContent = '0';
      document.getElementById('best').textContent = bestScore;
      document.getElementById('boostIndicator').classList.remove('active');
    }

    const OBSTACLE_COLORS = ['#00d4aa', '#3b82f6', '#a855f7', '#f59e0b', '#ec4899'];

    function getOccupiedLanesInDangerZone() {
      const dangerZoneTop = canvas.height * 0.25;
      const dangerZoneBottom = canvas.height + 50;
      const occupied = new Set();
      for (const obs of obstacles) {
        const obsBottom = obs.y + obs.height;
        const obsTop = obs.y;
        if (obsBottom > dangerZoneTop && obsTop < dangerZoneBottom) {
          occupied.add(obs.lane);
        }
      }
      return occupied;
    }

    function createObstacle() {
      const occupied = getOccupiedLanesInDangerZone();
      const availableLanes = [];
      for (let i = 0; i < LANES; i++) {
        if (!occupied.has(i)) availableLanes.push(i);
      }
      if (availableLanes.length === 0) return;
      const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];

      const laneWidth = canvas.width / LANES;
      const width = laneWidth * 0.65;
      const height = width * 1.4;
      obstacles.push({
        x: lane * laneWidth + (laneWidth - width) / 2,
        y: -height,
        width,
        height,
        lane,
        color: OBSTACLE_COLORS[Math.floor(Math.random() * OBSTACLE_COLORS.length)]
      });
    }

    function update() {
      if (!gameRunning) return;

      if (isCrashing) {
        crashFrame++;
        if (crashFrame >= CRASH_DURATION) {
          gameOver();
        }
        draw();
        if (gameRunning) animationId = requestAnimationFrame(gameLoop);
        return;
      }

      const now = Date.now();
      if (boostActive && now > boostEndTime) {
        boostActive = false;
        document.getElementById('boostIndicator').classList.remove('active');
      }

      const laneWidth = canvas.width / LANES;
      const baseSpeed = 4 + score * 0.008;
      const speed = boostActive ? baseSpeed * BOOST_MULTIPLIER : baseSpeed;
      roadOffset += boostActive ? 10 : 6;
      if (roadOffset > 45) roadOffset = 0;

      player.x = laneWidth * player.lane + (laneWidth - player.width) / 2;

      if (Math.random() < 0.018) createObstacle();

      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].y += speed;
        if (obstacles[i].y > canvas.height) {
          obstacles.splice(i, 1);
          score += 10;
          document.getElementById('score').textContent = score;
          if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('carGameBest', bestScore);
            document.getElementById('best').textContent = bestScore;
          }
        }
      }

      const overlapMargin = 8;
      for (const obs of obstacles) {
        const overlapX = Math.min(player.x + player.width - overlapMargin, obs.x + obs.width - overlapMargin) - Math.max(player.x + overlapMargin, obs.x + overlapMargin);
        const overlapY = Math.min(player.y + player.height - overlapMargin, obs.y + obs.height - overlapMargin) - Math.max(player.y + overlapMargin, obs.y + overlapMargin);
        if (overlapX > 0 && overlapY > 0) {
          isCrashing = true;
          crashFrame = 0;
          return;
        }
      }
    }

    function drawRoad() {
      const w = canvas.width;
      const h = canvas.height;
      const laneWidth = w / LANES;

      ctx.fillStyle = '#1a1e26';
      ctx.fillRect(0, 0, w, h);

      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, '#252b35');
      grad.addColorStop(0.5, '#1e232c');
      grad.addColorStop(1, '#252b35');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 2;
      for (let i = 1; i < LANES; i++) {
        const x = i * laneWidth;
        for (let y = (roadOffset % 48) - 48; y < h + 48; y += 48) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, Math.min(y + 28, h));
          ctx.stroke();
        }
      }

      ctx.fillStyle = '#0f1218';
      ctx.fillRect(0, 0, 14, h);
      ctx.fillRect(w - 14, 0, 14, h);

      ctx.strokeStyle = 'rgba(0, 212, 170, 0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.lineTo(14, h);
      ctx.moveTo(w - 14, 0);
      ctx.lineTo(w - 14, h);
      ctx.stroke();
    }

    function drawLamborghini(x, y, w, h, color, up, shakeX = 0, shakeY = 0) {
      const d = up ? 1 : -1;
      const cx = x + w / 2 + shakeX;
      const cy = y + h / 2 + shakeY;

      ctx.save();

      ctx.beginPath();
      ctx.moveTo(cx, cy - d * h * 0.42);
      ctx.lineTo(cx + w * 0.42, cy - d * h * 0.28);
      ctx.lineTo(cx + w * 0.42, cy + d * h * 0.32);
      ctx.lineTo(cx + w * 0.28, cy + d * h * 0.44);
      ctx.lineTo(cx + w * 0.08, cy + d * h * 0.46);
      ctx.lineTo(cx, cy + d * h * 0.44);
      ctx.lineTo(cx - w * 0.08, cy + d * h * 0.46);
      ctx.lineTo(cx - w * 0.28, cy + d * h * 0.44);
      ctx.lineTo(cx - w * 0.42, cy + d * h * 0.32);
      ctx.lineTo(cx - w * 0.42, cy - d * h * 0.28);
      ctx.closePath();

      const g = ctx.createLinearGradient(x, y, x + w, y + h);
      g.addColorStop(0, color);
      g.addColorStop(0.4, color);
      g.addColorStop(1, shade(color, -22));
      ctx.fillStyle = g;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1.2;
      ctx.stroke();

      ctx.fillStyle = 'rgba(8,10,16,0.95)';
      ctx.beginPath();
      ctx.moveTo(cx - w * 0.18, cy - d * h * 0.02);
      ctx.lineTo(cx + w * 0.18, cy - d * h * 0.02);
      ctx.lineTo(cx + w * 0.14, cy + d * h * 0.12);
      ctx.lineTo(cx - w * 0.14, cy + d * h * 0.12);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 0.8;
      ctx.stroke();

      ctx.fillStyle = '#fffef8';
      ctx.beginPath();
      ctx.arc(cx - w * 0.2, cy - d * h * 0.36, w * 0.055, 0, Math.PI * 2);
      ctx.arc(cx + w * 0.2, cy - d * h * 0.36, w * 0.055, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ff3333';
      ctx.beginPath();
      ctx.arc(cx - w * 0.2, cy + d * h * 0.36, w * 0.05, 0, Math.PI * 2);
      ctx.arc(cx + w * 0.2, cy + d * h * 0.36, w * 0.05, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx - w * 0.38, cy + d * h * 0.43);
      ctx.lineTo(cx + w * 0.38, cy + d * h * 0.43);
      ctx.stroke();

      ctx.restore();
    }

    function shade(hex, pct) {
      const n = parseInt(hex.replace('#', ''), 16);
      const amt = Math.round(2.55 * pct);
      const r = Math.min(255, Math.max(0, (n >> 16) + amt));
      const g = Math.min(255, Math.max(0, ((n >> 8) & 0xff) + amt));
      const b = Math.min(255, Math.max(0, (n & 0xff) + amt));
      return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    function draw() {
      drawRoad();
      let shakeX = 0, shakeY = 0;
      if (isCrashing) {
        const t = crashFrame / CRASH_DURATION;
        shakeX = (Math.random() - 0.5) * 12 * (1 - t);
        shakeY = (Math.random() - 0.5) * 8 * (1 - t);
      }
      drawLamborghini(player.x, player.y, player.width, player.height, '#ffd700', true, shakeX, shakeY);
      for (const o of obstacles) drawLamborghini(o.x, o.y, o.width, o.height, o.color || '#3b82f6', false, 0, 0);
      if (isCrashing) {
        const t = crashFrame / CRASH_DURATION;
        ctx.fillStyle = `rgba(255, 50, 50, ${0.4 * (1 - t)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function gameLoop() {
      update();
      draw();
      if (gameRunning) animationId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('startOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
      initGame();
      gameRunning = true;
      canvas.focus();
      gameLoop();
    }

    function gameOver() {
      gameRunning = false;
      cancelAnimationFrame(animationId);
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', startGame);

    function moveLeft() {
      if (gameRunning && player.lane > 0) player.lane--;
    }
    function moveRight() {
      if (gameRunning && player.lane < LANES - 1) player.lane++;
    }

    ['leftBtn', 'rightBtn'].forEach((id, i) => {
      const btn = document.getElementById(id);
      ['touchstart', 'mousedown'].forEach(ev => {
        btn.addEventListener(ev, e => {
          e.preventDefault();
          i === 0 ? moveLeft() : moveRight();
        }, { passive: false });
      });
    });

    let touchStartX = 0, touchStartY = 0, touchStartTime = 0, swipeHandled = false, lastClickWasTouch = false;
    const SWIPE_THRESHOLD = 30;
    const SWIPE_MAX_TIME = 300;

    canvas.addEventListener('touchstart', e => {
      if (!gameRunning || isCrashing) return;
      e.preventDefault();
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchStartTime = Date.now();
      swipeHandled = false;
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      if (!gameRunning || swipeHandled) return;
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
      if (!gameRunning || isCrashing) return;
      e.preventDefault();
      const t = e.changedTouches[0];
      if (!t || swipeHandled) return;
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchStartTime;
      if (Math.abs(dx) > SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy) && dt < SWIPE_MAX_TIME) {
        swipeHandled = true;
        lastClickWasTouch = true;
        dx > 0 ? moveRight() : moveLeft();
      } else {
        const r = canvas.getBoundingClientRect();
        if (t.clientX >= r.left && t.clientX <= r.right && t.clientY >= r.top && t.clientY <= r.bottom) {
          swipeHandled = true;
          lastClickWasTouch = true;
          ((t.clientX - r.left) / r.width < 0.5) ? moveLeft() : moveRight();
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchcancel', e => {
      swipeHandled = true;
    }, { passive: false });

    canvas.addEventListener('click', e => {
      if (!gameRunning || isCrashing) return;
      if (lastClickWasTouch) {
        lastClickWasTouch = false;
        return;
      }
      const r = canvas.getBoundingClientRect();
      if (e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom) {
        ((e.clientX - r.left) / r.width < 0.5) ? moveLeft() : moveRight();
      }
    });


    document.addEventListener('keydown', e => {
      if (!gameRunning) return;
      if (e.key === 'ArrowLeft') { e.preventDefault(); moveLeft(); }
      else if (e.key === 'ArrowRight') { e.preventDefault(); moveRight(); }
      else if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        activateBoost();
      }
    });

    function activateBoost() {
      if (!gameRunning || isCrashing) return;
      const now = Date.now();
      if (now - lastTouchTime < TOUCH_DEBOUNCE) return;
      lastTouchTime = now;
      boostActive = true;
      boostEndTime = now + BOOST_DURATION;
      document.getElementById('boostIndicator').classList.add('active');
    }

    document.querySelector('.game-container').addEventListener('touchstart', e => {
      if (!e.target.closest('button')) activateBoost();
    }, { passive: true });

    document.querySelector('.game-container').addEventListener('mousedown', e => {
      if (!e.target.closest('button')) activateBoost();
    });
    document.querySelector('.game-container').addEventListener('click', e => {
      if (!e.target.closest('button')) activateBoost();
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    initGame();
    draw();
  </script>
</body>
</html>
